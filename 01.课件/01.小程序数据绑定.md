# 小程序数据绑定

## 1.创建(C->Create)

1. Vue

   1. 在组件的配置对象中添加data属性,属性值必须是函数

   2. 面试题:为什么Vue的data只能是函数形式,不能写成对象?

      1. 每个组件自己独享的数据,应该放在data中

      2. 如果data是一个对象的话,那么当前组件生成的所有实例对象,将共享这一个data对象,最终data对象更新数据,所有相关的实例对象都会更新

      3. 如果data是一个函数的话,那么每次创建组件实例对象的时候,都会调用data函数,生成一个全新的data对象,保证每个组件实例都具有自己独享的data对象

      4. ```vue
         <template>
         	<div>
         		<A/>
         		<A/>
         		<A/>
         	</div>
         </template>

         <script>
         impory A from './A.vue';
         export default {
           name:"App",
           components:{
             A
           }
         }
         </script>
         ```

         ​

      5. 以上代码,页面上会显示3个A组件,同时生成3个不同的a组件实例对象

2. React

   1. 在class中书写state={}即可

   2. ```react
      class A extends React.Component{
        state = {
          ...
        }
      }
      注意:class中如果出现以上写法,那么每次创建实例对象的时候,都会自动添加state属性,属性值一定是一个全新的对象
      ```

      ​

3. 小程序

   1. **在配置对象中,添加data属性,属性值为对象即可**
   2. **面试题:为什么小程序的data可以写成对象形式?**
      1. **因为小程序会在页面加载的时候,将data使用JSON进行对象的深拷贝处理**
         1. **扩展:JSON进行深拷贝(乞丐版)**
            1. **var newData = JSON.parse(JSON.stringify(oldData))**
            2. **缺点:**
               1. **对象中如果存有函数,深拷贝完会变成undefined**
               2. **对象中如果存在Set或者Map对象,就会变成普通数组和普通对象**
               3. **对象中如果存在特殊数据类型,都会出现转换效果**
               4. **对象中不能递归嵌套对象**
      2. **所以可以保证每次的data都是一个全新的对象**

## 2.读取(R->Read)

1. 在模版中使用
   1. Vue
      1. 直接在template中使用插值语法({{msg}})即可展示对应的内容
      2. **问题:什么情况下需要使用插值语法?什么情况下不需要使用插值语法?**
         1. **将数据当作文本在标签中使用,需要加插值语法**
            1. **例如:<span>{{msg}}</span>**
         2. **将数据用在Vue的指令中,就不需要加插值语法**
            1. **例如:<span v-if="msg">hello</span>**
   2. React
      1. 直接在render函数返回的结构中,书写"{this.state.msg}"即可
   3. 小程序
      1. **在wxml中,使用插值语法({{msg}})展示数据即可**
      2. **注意:只要想在wxml中,使用data的数据,就一定要加插值语法,无论是不是在小程序的指令中**
2. 在js代码中使用
   1. Vue
      1. 语法:this.msg
      2. 流程:
         1. 通过this.msg读取数据,会触发**数据代理**的get方法
         2. 数据代理的get方法,会读取this.$data.msg的值
         3. 由于想要读取this.$data.msg的值,会触发**数据劫持**的get方法
         4. 最终获取到msg属性值的并进行返回
   2. React
      1. 语法:this.state.msg
      2. **因为React中,没有数据代理,所以无法省略.state,直接写为this.msg**
   3. 小程序
      1. **语法:this.data.msg**
      2. **因为小程序中,没有数据代理,只能自己通过先找到data对象,再从data对象身上找到对应的属性进行读取**

## 3.修改(U->Update)

1. Vue
   1. 语法:this.msg=123
   2. 流程:
      1. 设置this.msg值,会触发**数据代理**的set方法
      2. set方法中,会将赋的最新值交给this.$data.msg进行设置
      3. 由于开始设置this.$data.msg的值,会触发**数据劫持**的set方法
      4. 在set方法中,更新当前msg属性的同时,还会使用**dep.notify方法通知DOM进行更新**
   3. **面试题:请问Vue中更新数据是同步更新还是异步更新?**
      1. **同步更新**
   4. **面试题2:请问Vue中更新DOM是同步更新还是异步更新?**
      1. **异步更新**
      2. **使用场景:后台管理系统编辑模式切换**
2. React(持久化状态框架)
   1. 语法:this.setState({msg:123})
   2. React中必须使用setState才能更新数据和DOM结构,**因为React没有数据劫持(也就是没有响应式效果)**
   3. 面试题:请问React中更新数据是同步更新还是异步更新?
      1. 异步更新
3. 小程序
   1. **语法:this.setData({msg:123})**
   2. **小程序中必须使用setData更新数据和页面,可以证明小程序没有数据劫持(也就是没有响应式效果)**
   3. **面试题:请问小程序更新数据是同步更新还是异步更新?**
      1. **同步更新**
   4. **面试题2:请问小程序更新页面是同步更新还是异步更新?**
      1. **异步更新**
4. 问题:为什么所有的框架都要异步更新DOM?
   1. 异步更新DOM,其实就是将多次更新DOM合并为一次进行更新,也就是以最后一次的结果进行渲染
      1. 相当于对DOM的更新操作实现了防抖操作
   2. 通过节流和防抖,可以控制函数在一定时间之内只执行一次操作
   3. 节流就是在一段时间之内,只执行第一次操作,后续操作都不执行
      1. **特点:操作会立即执行,但是数据时效性较差(时效性指的是数据的新旧程度)**
      2. **使用场景:登录界面的登录按钮发送请求操作**
   4. 防抖就是在一段时间之内,如果再次触发相同操作,上一个操作不会执行,最终无论触发多少次,只会执行最后一次
      1. **特点:数据时效性较好,但是操作会延迟执行(必须在触发当前操作之后一段时间内,没有再次操作才会执行)**
      2. **使用场景:搜索框中的单词联想功能**

## 4.删除(D->Delete)

​	Vue可以通过Vue.delete或者this.$delete删除某个响应式属性