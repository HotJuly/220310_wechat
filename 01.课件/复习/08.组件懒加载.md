# 组件懒加载

1. 前言

   1. 如果没有使用组件懒加载,项目以生产环境编译打包,最后会返回一个dist文件夹
      1. index.html
      2. index.js
      3. 注意:
         1. 如果项目中存在图片
            1. 图片小于1MB,那么就会以base64格式进行编译,最终会生成base64字符串,放入img的src中
            2. 图片大于1MB,那么该图片就会作为单独文件进行输出,放入文件夹images
      4. 假设项目中具有10个组件文件,每个文件的大小为1MB,那么index.js会存储当前项目所有的代码
         1. index.js文件具有10个组件的代码,文件大小为10*1=10MB
   2. 项目存在的问题:其实用户首次请求只是想看到首页的内容,但是结果把所有组件的代码都请求回来,**导致请求占用的带宽变大,首屏渲染速度变慢,页面白屏时间变长,用户体验极差**

2. ES6模块化语法

   1. 静态引入

      1. import ... from '路径'

      2. 该语法在项目上线之后不会存在,写该行代码的地方会将对应的依赖文件代码引入过来,最终相当于所有的代码都会集中在一个文件中

      3. ```
         import Home from '@/components/Home.vue'

         new VueRouter({
           routes:[{
             path:"/home",
             component:Home
           }]
         })
         ```

         ​

   2. 动态引入

      1. import()

      2. 该语法在上线之后依旧存在,当webpack编译时,遇到了import函数写法,会将被引入的文件单独切割成为一个js文件,后续项目需要用到当前切割的代码,需要重新发送请求获取

      3. ```
         new VueRouter({
           routes:[{
             path:"/home",
             component:()=>import('@/components/Home.vue')
           }]
         })
         ```

         ​

3. 组件懒加载的优点

   1. 使用import函数实现组件懒加载之后,1中提到的项目就会一共具有11个文件:
      1. index.html
      2. index.js
      3. 其余9个组件的代码
   2. 此时index.js中只会存有首页的代码,不会拥有其余9个组件的代码,体积变小,变为1MB
   3. 也就是说,当用户请求页面进行展示的时候,只需要请求index.js文件,此时相比于之前,**首屏渲染请求资源变少,带宽占用变小,首屏渲染速度变快,最终页面白屏时间变短,用户可以更早的看到页面**

4. 组件懒加载的缺点

   1. 由于index.js文件中,没有其余组件的代码,那么用户如果想要显示查看其余组件,就需要发送请求,找服务器获取对应页面的js文件,进行解析,最终执行并展示
   2. **后续页面渲染速度都会变慢,因为后续页面首次展示的时候,都需要发送请求获取文件**

5. 组件预加载

   1. **在用户不知不觉间,悄悄地将未来可能使用到的资源提前请求回来**
   2. **效果:在用户看首页代码的时候,将其余组件的代码都提前请求回来,放到浏览器内存中**
   3. **优点:最终后续页面展示都是内存级别的操作,页面切换速度变快,不需要等到用户要看其余页面在发送请求**
   4. **缺点:比较费流量**
   5. **实现原理:使用script或者img等标签,还有使用ajax请求都可以,提前发送请求即可**
   6. Vue脚手架中自带组件预加载,不需要我们进行特殊配置